<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="String1" xml:space="preserve">
    <value>This sample shows some basic integer arithmetic</value>
  </data>
  <data name="String10" xml:space="preserve">
    <value>Some simple 'for' loops</value>
  </data>
  <data name="String11" xml:space="preserve">
    <value>Some simple nested 'for' loops</value>
  </data>
  <data name="String12" xml:space="preserve">
    <value>A simple 'while' loop that counts, skipping by 2</value>
  </data>
  <data name="String13" xml:space="preserve">
    <value>A simple 'while' loops that busy-waits until the given time-span has passed</value>
  </data>
  <data name="String14" xml:space="preserve">
    <value>Declaring a simple recursive function</value>
  </data>
  <data name="String15" xml:space="preserve">
    <value>This sample demonstrates basic array construction.</value>
  </data>
  <data name="String16" xml:space="preserve">
    <value>This sample demonstrates more basic array construction.</value>
  </data>
  <data name="String17" xml:space="preserve">
    <value>Create a histogram of the occurrences of particular letters</value>
  </data>
  <data name="String18" xml:space="preserve">
    <value>Create a histogram of the occurrences of particular unicode characters using a dictionary.</value>
  </data>
  <data name="String19" xml:space="preserve">
    <value>This sample shows simple uses of tuples</value>
  </data>
  <data name="String2" xml:space="preserve">
    <value>This sample shows some basic floating point arithmetic</value>
  </data>
  <data name="String20" xml:space="preserve">
    <value>This sample demonstrates basic list construction</value>
  </data>
  <data name="String21" xml:space="preserve">
    <value>This sample demonstrates a simple generative list comprehension to specify lists</value>
  </data>
  <data name="String22" xml:space="preserve">
    <value>This sample shows simple uses of lists and functions that pattern match on them.</value>
  </data>
  <data name="String23" xml:space="preserve">
    <value>This sample shows simple uses of 'map</value>
  </data>
  <data name="String24" xml:space="preserve">
    <value>This sample shows simple uses of 'iter'</value>
  </data>
  <data name="String25" xml:space="preserve">
    <value>This sample shows simple uses of 'iteri'</value>
  </data>
  <data name="String26" xml:space="preserve">
    <value>This sample shows simple uses of 'fold' to accumulate a result over a list</value>
  </data>
  <data name="String27" xml:space="preserve">
    <value>This sample shows how to filter a list</value>
  </data>
  <data name="String28" xml:space="preserve">
    <value>Project from a list</value>
  </data>
  <data name="String29" xml:space="preserve">
    <value>Create some optional values, print them and match on them.</value>
  </data>
  <data name="String3" xml:space="preserve">
    <value>This sample shows how to convert between various numeric types</value>
  </data>
  <data name="String30" xml:space="preserve">
    <value>Here we return an option from a function indicating the opening hours of a shop, if any.</value>
  </data>
  <data name="String31" xml:space="preserve">
    <value>This sample demonstrates basic sequence construction.</value>
  </data>
  <data name="String32" xml:space="preserve">
    <value>This sample demonstrates basic sequence iteration.</value>
  </data>
  <data name="String33" xml:space="preserve">
    <value>.iter applies a given function to each element in the collection, returning a value of unit ().</value>
  </data>
  <data name="String34" xml:space="preserve">
    <value>.map applies a given function to each element in the collection, returning a new collection.</value>
  </data>
  <data name="String35" xml:space="preserve">
    <value>.reduce applies a given function to the collection, threading an accumulator argument through and returning a single value.</value>
  </data>
  <data name="String36" xml:space="preserve">
    <value>.filter applies a given function to the collection, returning only those elements for which the given predicate returns true.</value>
  </data>
  <data name="String37" xml:space="preserve">
    <value>.choose applies a given function to the collection, returning an array of results x where the function evaluates to Some(x).</value>
  </data>
  <data name="String38" xml:space="preserve">
    <value>F# supports structural comparison and equality of values with the same type.  This sample shows the results of some simple structural comparison operations.</value>
  </data>
  <data name="String39" xml:space="preserve">
    <value>F# supports structural hashing on values. Typically only F# record/union structured terms are traversed, though this can be customized on a per-type basis. This sample shows the results of some simple structural hashing operations.</value>
  </data>
  <data name="String4" xml:space="preserve">
    <value>Declaring and calling functions within the body of another function</value>
  </data>
  <data name="String40" xml:space="preserve">
    <value>Discriminated unions give a way of building types from the disjoint union of two or more existing types. This sample shows how to build one such type and how to decompose its values.</value>
  </data>
  <data name="String41" xml:space="preserve">
    <value>Discriminated unions are excellent for representing tree structures.</value>
  </data>
  <data name="String42" xml:space="preserve">
    <value>Records are concrete type definitions that hold data in an unordered, named structure.</value>
  </data>
  <data name="String43" xml:space="preserve">
    <value>Examples of cloning records using 'with' keyword and accessing record fields using . (dot).</value>
  </data>
  <data name="String44" xml:space="preserve">
    <value>F# allows values to be associated with type names, i.e. the type name can be used as a container for 'members' of that type. These are treated the same way as .NET object model members.</value>
  </data>
  <data name="String45" xml:space="preserve">
    <value>Records and Pattern Matching</value>
  </data>
  <data name="String46" xml:space="preserve">
    <value>Discriminated unions and records can be defined simultaneously to give mutually recursive collections of types.</value>
  </data>
  <data name="String47" xml:space="preserve">
    <value>Enums are lightweight types, similar to discriminated unions. Unlike discriminated unions, each data tag must be given a constant value of the same type</value>
  </data>
  <data name="String48" xml:space="preserve">
    <value>Structs are lightweight data structures, stored on the Stack. They use value equality comparison.</value>
  </data>
  <data name="String49" xml:space="preserve">
    <value>Classes are custom types containing data (known as 'fields'), methods, and properties ( methods without parameters). Classes are reference types and are stored on the Heap. Classes must be constructed and instantiated to use. Unlike C#, no default constructor is provided, one must be defined.</value>
  </data>
  <data name="String5" xml:space="preserve">
    <value>Introduction to using lambda expressions</value>
  </data>
  <data name="String50" xml:space="preserve">
    <value>Classes can contain methods of general form and properties.</value>
  </data>
  <data name="String51" xml:space="preserve">
    <value>The 'use' binding indicates that the IDisposable.Dispose method should be called on the object at the end of its lexical scope. In this case it closes the file deterministically.</value>
  </data>
  <data name="String52" xml:space="preserve">
    <value>Line-directed text file input using .NET Stream/StreamReader/StreamWriter abstractions.</value>
  </data>
  <data name="String53" xml:space="preserve">
    <value>Line-directed text file input using .NET Stream/StreamReader/StreamWriter abstractions.</value>
  </data>
  <data name="String54" xml:space="preserve">
    <value>Read an entire text file as a string using .NET I/O utilities and abstractions.</value>
  </data>
  <data name="String55" xml:space="preserve">
    <value>Read an entire text file as a string using .NET I/O utilities and abstractions.</value>
  </data>
  <data name="String56" xml:space="preserve">
    <value>This sample shows how to use the bitwise integer operations</value>
  </data>
  <data name="String57" xml:space="preserve">
    <value>Create a set of particular unicode characters using a Microsoft.FSharp.Collections.Set.</value>
  </data>
  <data name="String58" xml:space="preserve">
    <value>Create a histogram of the occurrences of particular unicode characters using a Microsoft.FSharp.Collections.Map.</value>
  </data>
  <data name="String59" xml:space="preserve">
    <value>A longer sample showing how to use interfaces to model 'data' objects such as abstract points.  Somewhat contrived, since multiple repreentations of points are unlikely practice, but for larger computational objects maintaining flexibility of representation through using interfaces or function values is often crucial.</value>
  </data>
  <data name="String6" xml:space="preserve">
    <value>How to raise a simple exception</value>
  </data>
  <data name="String60" xml:space="preserve">
    <value>Build an IEnumerable&lt;string list&gt; for on-demand reading of a CSV file using .NET I/O utilities and abstractions</value>
  </data>
  <data name="String61" xml:space="preserve">
    <value>type provider sample. Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String62" xml:space="preserve">
    <value>type provider sample using IN.  Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String63" xml:space="preserve">
    <value>type provider sample using EXISTS .  Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String64" xml:space="preserve">
    <value>type provider sample using GroupBy.  Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String65" xml:space="preserve">
    <value>type provider sample using GroupBy and OrderBy DESC.  Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String66" xml:space="preserve">
    <value>type provider sample using TOP.  Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String67" xml:space="preserve">
    <value>type provider sample: LEFT JOIN.  Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String68" xml:space="preserve">
    <value>type provider sample: COUNT.  Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String69" xml:space="preserve">
    <value>type provider sample: DISTINCT.  Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String7" xml:space="preserve">
    <value>How to raise and catch a 'Failure' exception</value>
  </data>
  <data name="String70" xml:space="preserve">
    <value>type provider sample: DISTINCT COUNT.  Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String71" xml:space="preserve">
    <value>type provider sample: TOP and nullable.  Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String72" xml:space="preserve">
    <value>type provider sample: UNION.  Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String73" xml:space="preserve">
    <value>type provider sample: CASE.  Use the CreateFSharpSampleDatabase.sql to setup your database tables.</value>
  </data>
  <data name="String8" xml:space="preserve">
    <value>Raising a 'KeyNotFoundException' exception, and using exception patterns</value>
  </data>
  <data name="String9" xml:space="preserve">
    <value>Raising an 'ArgumentException' exception, and filtering for .NET exceptions</value>
  </data>
  <data name="TypeProvider.OData.Sample0" xml:space="preserve">
    <value>Use the OData service to access Azure data market data source. For this sample, we access the UK travel information data from Azure data market. You need Azure data maket user name and credential to access this free data.</value>
  </data>
  <data name="TypeProvider.Others.Sample0" xml:space="preserve">
    <value>Use the resx type provider. The string1 and string2 are defined in the resource file.</value>
  </data>
</root>